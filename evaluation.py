"""

_project_ : LLMs for Code and Spec Review

_team_ : Cmput469, T5-InnovAiTors

_reference_ : 
https://www.freecodecamp.org/news/what-is-rouge-and-how-it-works-for-evaluation-of-summaries-e059fb8ac840/
[ROUGE: A Package for Automatic Evaluation of Summaries](https://aclanthology.org/W04-1013) (Lin, 2004)

_description_ :
The functions defined in the following script can be used to calculate similarity scores,
using recall and precision values, for comparing answers generated by our model to the golden ref.

recall = number_of_overlapping_words / total_words_in_reference_summary
precision = number_of_overlapping_words / total_words_in_system_summary

"""

from typing import List, Tuple


def ngram(system_answer: str, ref_answer: str, n: int) -> List[str]:
    """
    Measures unigram, bigram, trigram and higher order n-gram overlap.
    Returns n-gram -> list of strings, where each string has n words
    common to both the provided arguments.
    """
    common_strings = []
    system_strings = n_split_answer(system_answer, n)
    ref_strings = n_split_answer(ref_answer, n)
    for system_string in system_strings:
        if system_string in ref_strings:
            common_strings.append(system_string)
    return common_strings


def n_split_answer(answer: str, n: int) -> List[str]:
    """
    Splits the answer string into sub-strings of length n in order
    """
    n_size_strings = []
    answer_string = answer.split()
    answer_string_size = len(answer_string)
    for i in range(answer_string_size):
        if i + n <= answer_string_size:
            n_size_string = ""
            for j in range(n):
                n_size_string += answer_string[i+j].strip("!.,;:'\"") + " "
            n_size_strings.append(n_size_string.strip())
    return n_size_strings


def lcs(system_answer: str, ref_answer: str) -> List[str]:
    """
    Measures and returns list of longest matching sequences of words using LCS
    """
    lcs_gram = []
    for i in range(1, len(ref_answer.split())+1):
        potential_lcs_gram = ngram(system_answer, ref_answer, i)
        if potential_lcs_gram:
            lcs_gram = potential_lcs_gram
        else:
            break
    return lcs_gram


def skip_n(answer: str, n: int) -> List[str]:
    """
    
    """
    words_with_max_n_gaps = []
    answer_string = answer.split()
    answer_string_size = len(answer_string)
    for i in range(answer_string_size):
        current_string = answer_string[i]
        for j in range(1, n+2):
                if i + j < answer_string_size:
                    string_to_add = current_string + " " + answer_string[i+j].strip("!.,;:'\"")
                    words_with_max_n_gaps.append(string_to_add.strip())
    return words_with_max_n_gaps


def rouge_n(system_answer: str, ref_answer: str, n: int) -> Tuple[float, float]:
    """
    Calculates and returns recall and precision for system's answer given the reference answer
    using ROUGE-N approach
    """
    recall, precision = 0, 0
    number_of_overlapping_words = len(ngram(system_answer, ref_answer, n))
    total_words_in_reference_summary = len(n_split_answer(ref_answer, n))
    total_words_in_system_summary = len(n_split_answer(system_answer, n))
    if total_words_in_reference_summary:
        recall = number_of_overlapping_words / total_words_in_reference_summary
    if total_words_in_system_summary:
        precision = number_of_overlapping_words / total_words_in_system_summary
    return (recall, precision)


def rouge_l(system_answer: str, ref_answer: str) -> Tuple[float, float]:
    """
    Calculates and returns recall and precision for system's answer given the reference answer
    using ROUGE-L approach
    """
    recall, precision = 0, 0
    _lcs = lcs(system_answer, ref_answer)
    if _lcs:
        any_lcs = _lcs[0]
        number_of_words_in_lcs = len(any_lcs.split())
        total_words_in_reference_summary = len(n_split_answer(ref_answer, 1))
        total_words_in_system_summary = len(n_split_answer(system_answer, 1))
        if total_words_in_reference_summary:
            recall = number_of_words_in_lcs / total_words_in_reference_summary
        if total_words_in_system_summary:
            precision = number_of_words_in_lcs / total_words_in_system_summary
    return (recall, precision)


def rouge_s(system_answer: str, ref_answer: str) -> Tuple[float, float]:
    """
    Calculates and returns recall and precision for system's answer given the reference answer
    using ROUGE-S approach
    """
    recall, precision = 0, 0
    skip_2_system = skip_n(system_answer, 2)
    skip_2_ref = skip_n(ref_answer, 2)
    # find s the number of skip-bigram matches between system and ref answers
    skip_2_system_ref_intersection = []
    for skip_2_system_string in skip_2_system:
        if skip_2_system_string in skip_2_ref:
            skip_2_system_ref_intersection.append(skip_2_system_string)
    print(skip_2_system_ref_intersection)
    # calculate recall and precision
    if skip_2_ref:
        recall = len(skip_2_system_ref_intersection) / len(skip_2_ref)
    if skip_2_system:
        precision = len(skip_2_system_ref_intersection) / len(skip_2_system)
    return (recall, precision)