"""

_project_ : LLMs for Code and Spec Review

_team_ : Cmput469, T5-InnovAiTors

_reference_ : 
https://www.freecodecamp.org/news/what-is-rouge-and-how-it-works-for-evaluation-of-summaries-e059fb8ac840/
[ROUGE: A Package for Automatic Evaluation of Summaries](https://aclanthology.org/W04-1013) (Lin, 2004)

_description_ :
The functions defined in the following script can be used to calculate similarity scores,
using recall and precision values, for comparing answers generated by our model to the golden ref.

recall = number_of_overlapping_words / total_words_in_reference_summary
precision = number_of_overlapping_words / total_words_in_system_summary

"""

from typing import List, Tuple


def ngram(system_answer: str, ref_answer: str, n: int) -> List[str]:
    """
    Measures unigram, bigram, trigram and higher order n-gram overlap.
    Returns n-gram -> list of strings, where each string has n words
    common to both the provided arguments.
    """
    common_strings = []
    system_strings = n_split_answer(system_answer, n)
    ref_strings = n_split_answer(ref_answer, n)
    for system_string in system_strings:
        if system_string in ref_strings:
            common_strings.append(system_string)
    return common_strings


def n_split_answer(answer: str, n: int) -> List[str]:
    """
    Splits the answer string into sub-strings of length n in order
    """
    n_size_strings = []
    answer_string = answer.split()
    answer_string_size = len(answer_string)
    for i in range(answer_string_size):
        if i + n <= answer_string_size:
            n_size_string = ""
            for j in range(n):
                n_size_string += answer_string[i+j].strip("!.,;:'\"") + " "
            n_size_strings.append(n_size_string.strip())
    return n_size_strings


def lcs(system_answer: str, ref_answer: str) -> List[str]:
    """
    Measures and returns list of longest matching sequences of words using LCS
    """
    lcs_gram = []
    for i in range(1, len(ref_answer.split())+1):
        potential_lcs_gram = ngram(system_answer, ref_answer, i)
        if potential_lcs_gram:
            lcs_gram = potential_lcs_gram
        else:
            break
    return lcs_gram


def rouge_n(system_answer: str, ref_answer: str, n: int) -> Tuple[float, float]:
    """
    Calculates and returns recall and precision for system's answer given the reference answer
    """
    recall, precision = 0, 0
    number_of_overlapping_words = len(ngram(system_answer, ref_answer, n))
    total_words_in_reference_summary = len(n_split_answer(ref_answer, n))
    total_words_in_system_summary = len(n_split_answer(system_answer, n))
    if total_words_in_reference_summary:
        recall = number_of_overlapping_words / total_words_in_reference_summary
    if total_words_in_system_summary:
        precision = number_of_overlapping_words / total_words_in_system_summary
    return (recall, precision)


def rouge_l(system_answer: str, ref_answer: str) -> Tuple[float, float]:
    recall, precision = 0, 0
    _lcs = lcs(system_answer, ref_answer)
    print(_lcs)
    if _lcs:
        any_lcs = _lcs[0]
        number_of_words_in_lcs = len(any_lcs.split())
        total_words_in_reference_summary = len(n_split_answer(ref_answer, 1))
        total_words_in_system_summary = len(n_split_answer(system_answer, 1))
        if total_words_in_reference_summary:
            recall = number_of_words_in_lcs / total_words_in_reference_summary
        if total_words_in_system_summary:
            precision = number_of_words_in_lcs / total_words_in_system_summary
    return (recall, precision)